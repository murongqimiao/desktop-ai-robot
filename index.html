<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Robot Face</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 300px;
      height: 200px;
      background: transparent; /* 透明背景 */
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      overflow: hidden; /* 隐藏溢出内容 */
      -webkit-app-region: drag; /* 使窗口可拖动 */
      border-radius: 20px; /* 与 face 的圆角一致 */
      transform: scale(0.5);
      transform-origin: left top;
    }
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #4a5568;
      border-radius: 10px;
      -webkit-app-region: drag; /* 确保背景也可以拖动 */
    }

    /* 脸部轮廓 - 高宽比 2:3 (高度:宽度 = 2:3) */
    .face {
      width: 300px;
      height: 200px; /* 300 * 2/3 = 200 */
      /* background: linear-gradient(145deg, #e0e0e0, #ffffff); */
      border-radius: 20px;
      position: relative;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.3),
        inset 0 -10px 20px rgba(0, 0, 0, 0.1),
        inset 0 10px 20px rgba(255, 255, 255, 0.5);
      border: 3px solid rgba(255, 255, 255, 0.3);
      perspective: 300px;
      transform-style: preserve-3d;
    }

    /* 眼睛容器 - 外层 */
    .eye {
      width: 80px;
      height: 80px;
      background: linear-gradient(145deg, #ffffff, #e0e0e0);
      border-radius: 16px;
      position: absolute;
      top: 50%;
      transform: translateY(-50%) translateZ(10px);
      transform-style: preserve-3d;
      transform-origin: center center;
      z-index: 10;
      box-shadow: 
        inset 0 5px 15px rgba(0, 0, 0, 0.2),
        0 5px 15px rgba(0, 0, 0, 0.3);
      border: 2px solid rgba(0, 0, 0, 0.1);
      overflow: hidden;
      transition: top 0.4s ease-out, left 0.4s ease-out, right 0.4s ease-out, transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* 3D变换 - 向下看（悲伤，倒梯形效果） */
    .eye.face-down {
      top: 70%;
      transform: translateY(-50%) translateZ(10px) rotateX(-30deg);
    }

    /* 3D变换 - 向上看 */
    .eye.face-up {
      top: 30%;
      transform: translateY(-50%) translateZ(10px) rotateX(30deg);
    }

    /* 3D变换 - 向左看 */
    .eye.face-left.left {
      left: 40px;
      transform: translateY(-50%) translateZ(10px) rotateY(-25deg);
    }

    .eye.face-left.right {
      right: 80px;
      transform: translateY(-50%) translateZ(10px) rotateY(-25deg);
    }

    /* 3D变换 - 向右看 */
    .eye.face-right.left {
      left: 80px;
      transform: translateY(-50%) translateZ(10px) rotateY(25deg);
    }

    .eye.face-right.right {
      right: 40px;
      transform: translateY(-50%) translateZ(10px) rotateY(25deg);
    }

    /* 3D变换 - 正常（正面） */
    .eye.face-normal {
      top: 50%;
      transform: translateY(-50%) translateZ(10px) rotateX(0deg) rotateY(0deg);
    }

    /* 眼睛位置移动 */
    .eye.position-up {
      top: 30%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-down {
      top: 70%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-center {
      top: 50%;
      transform: translateY(-50%) translateZ(10px);
    }

    /* 左移位置 - 两个眼睛都向左移动 */
    .eye.position-left {
      top: 50%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-left.left {
      left: 40px; /* 向左移动 */
    }

    .eye.position-left.right {
      right: 80px; /* 向左移动（right值增大表示向左） */
    }

    /* 右移位置 - 两个眼睛都向右移动 */
    .eye.position-right {
      top: 50%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-right.left {
      left: 80px; /* 向右移动 */
    }

    .eye.position-right.right {
      right: 40px; /* 向右移动（right值减小表示向右） */
    }

    /* 左上位置 - 两个眼睛都向左上移动 */
    .eye.position-up-left {
      top: 30%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-up-left.left {
      left: 40px; /* 向左移动 */
    }

    .eye.position-up-left.right {
      right: 80px; /* 向左移动（right值增大表示向左） */
    }

    /* 右上位置 - 两个眼睛都向右上移动 */
    .eye.position-up-right {
      top: 30%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-up-right.left {
      left: 80px; /* 向右移动 */
    }

    .eye.position-up-right.right {
      right: 40px; /* 向右移动（right值减小表示向右） */
    }

    /* 左下位置 - 两个眼睛都向左下移动 */
    .eye.position-down-left {
      top: 70%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-down-left.left {
      left: 40px; /* 向左移动 */
    }

    .eye.position-down-left.right {
      right: 80px; /* 向左移动（right值增大表示向左） */
    }

    /* 右下位置 - 两个眼睛都向右下移动 */
    .eye.position-down-right {
      top: 70%;
      transform: translateY(-50%) translateZ(10px);
    }

    .eye.position-down-right.left {
      left: 80px; /* 向右移动 */
    }

    .eye.position-down-right.right {
      right: 40px; /* 向右移动（right值减小表示向右） */
    }

    /* 眨眼动画 - 通过瞳孔缩放实现 */
    @keyframes blink {
      0% {
        transform: translate(-50%, -50%) translateZ(5px) scaleY(1);
        opacity: 1;
      }
      30% {
        transform: translate(-50%, -50%) translateZ(5px) scaleY(0.1);
        opacity: 0.8;
      }
      50% {
        transform: translate(-50%, -50%) translateZ(5px) scaleY(0);
        opacity: 0;
      }
      70% {
        transform: translate(-50%, -50%) translateZ(5px) scaleY(0.1);
        opacity: 0.8;
      }
      100% {
        transform: translate(-50%, -50%) translateZ(5px) scaleY(1);
        opacity: 1;
      }
    }

    /* 眨眼状态 */
    .pupil.blinking {
      animation: blink 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* 左眼位置 */
    .eye.left {
      left: 60px;
    }

    /* 右眼位置 */
    .eye.right {
      right: 60px;
    }

    /* 瞳孔 - 内层 */
    .pupil {
      width: 32px;
      height: 32px;
      background: linear-gradient(145deg, #4a5568, #1a202c);
      border-radius: 8px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateZ(5px);
      transform-origin: center;
      z-index: 1;
      box-shadow: 
        inset 0 2px 5px rgba(0, 0, 0, 0.5),
        0 2px 10px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s ease-out;
    }

    /* 眼睛移动动画 */
    .pupil.look-left {
      transform: translate(-70%, -50%) translateZ(5px);
    }

    .pupil.look-right {
      transform: translate(-30%, -50%) translateZ(5px);
    }

    .pupil.look-up {
      transform: translate(-50%, -70%) translateZ(5px);
    }

    .pupil.look-down {
      transform: translate(-50%, -30%) translateZ(5px);
    }

    .pupil.look-up-left {
      transform: translate(-70%, -70%) translateZ(5px);
    }

    .pupil.look-up-right {
      transform: translate(-30%, -70%) translateZ(5px);
    }

    .pupil.look-down-left {
      transform: translate(-70%, -30%) translateZ(5px);
    }

    .pupil.look-down-right {
      transform: translate(-30%, -30%) translateZ(5px);
    }

    .pupil.look-center {
      transform: translate(-50%, -50%) translateZ(5px);
    }

    /* 转圈思考动画 */
    @keyframes think {
      0% {
        transform: translate(-50%, -50%) translateZ(5px) rotate(0deg) translateX(20px) rotate(0deg);
      }
      100% {
        transform: translate(-50%, -50%) translateZ(5px) rotate(360deg) translateX(20px) rotate(-360deg);
      }
    }

    .pupil.thinking {
      animation: think 2s linear infinite;
    }

    /* 瞳孔高光效果 */
    .pupil::after {
      content: '';
      width: 8px;
      height: 8px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 2px;
      position: absolute;
      top: 20%;
      left: 25%;
    }

    /* 控制按钮区域 - 隐藏 */
    .controls {
      display: none;
    }

    /* 嘴巴容器 */
    .mouth {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%) translateZ(5px);
      width: 60px;
      height: 20px;
      z-index: 5;
      transition: all 0.4s ease-out;
    }

    /* 嘴巴 - 横线（普通情绪） */
    .mouth.line {
      height: 3px;
      background: white;
      border-radius: 2px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* 嘴巴 - 圆圈（狡黠） */
    .mouth.circle {
      width: 20px;
      height: 20px;
      border: 3px solid white;
      border-radius: 50%;
      background: transparent;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* 嘴巴 - 向上弧线（高兴） */
    .mouth.arc-up {
      height: 30px;
      width: 50px;
      border: 3px solid white;
      border-top: none;
      border-radius: 0 0 50px 50px;
      background: transparent;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* 嘴巴 - 向下弧线（悲伤） */
    .mouth.arc-down {
      height: 30px;
      width: 50px;
      border: 3px solid white;
      border-bottom: none;
      border-radius: 50px 50px 0 0;
      background: transparent;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* 嘴巴 - 矩形（带圆角，说话时的初始状态） */
    .mouth.rectangle {
      width: 40px;
      height: 20px;
      border: 3px solid white;
      border-radius: 10px;
      background: transparent;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    /* 说话动画 - 从矩形到横线反复变化 */
    @keyframes speaking {
      0%, 100% {
        width: 40px;
        height: 20px;
        border-radius: 10px;
        border: 3px solid white;
        background: transparent;
      }
      50% {
        width: 60px;
        height: 3px;
        border-radius: 2px;
        border: none;
        background: white;
      }
    }

    /* 说话状态 */
    .mouth.speaking {
      width: 40px;
      height: 20px;
      border: 3px solid white;
      border-radius: 10px;
      background: transparent;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      animation: speaking 0.5s ease-in-out infinite;
    }
  </style>
</head>
<body>
  <!-- 脸部轮廓 -->
  <div class="face">
    <!-- 左眼 - 外层div -->
    <div class="eye left">
      <!-- 瞳孔 - 内层div -->
      <div class="pupil"></div>
    </div>
    <!-- 右眼 - 外层div -->
    <div class="eye right">
      <!-- 瞳孔 - 内层div -->
      <div class="pupil"></div>
    </div>
    <!-- 嘴巴 -->
    <div class="mouth line"></div>
  </div>

  <script type="module">
    // 获取所有眼睛和瞳孔元素
    const eyes = document.querySelectorAll('.eye');
    const pupils = document.querySelectorAll('.pupil');
    let isThinking = false;
    let thinkingTimeout = null;

    // 眨眼动画 - 通过瞳孔缩放实现
    function triggerBlink() {
      pupils.forEach(pupil => {
        // 移除之前的眨眼类（如果存在）
        pupil.classList.remove('blinking');
        // 强制重排以重新触发动画
        void pupil.offsetWidth;
        // 添加眨眼类
        pupil.classList.add('blinking');
        // 动画结束后移除类
        setTimeout(() => {
          pupil.classList.remove('blinking');
        }, 400);
      });
    }

    // 眼睛看向不同方向
    function lookDirection(direction) {
      // 如果正在思考，先停止思考动画
      if (isThinking) {
        stopThinking();
      }

      // 移除所有方向类和眨眼类
      pupils.forEach(pupil => {
        pupil.classList.remove('look-left', 'look-right', 'look-up', 'look-down', 
          'look-up-left', 'look-up-right', 'look-down-left', 'look-down-right',
          'look-center', 'thinking', 'blinking');
      });

      // 添加新的方向类
      if (direction !== 'center') {
        pupils.forEach(pupil => {
          pupil.classList.add(`look-${direction}`);
        });
      } else {
        pupils.forEach(pupil => {
          pupil.classList.add('look-center');
        });
      }
    }

    // 思考转圈动画
    function triggerThinking() {
      if (isThinking) {
        stopThinking();
        return;
      }

      isThinking = true;
      
      // 先回到中心
      pupils.forEach(pupil => {
        pupil.classList.remove('look-left', 'look-right', 'look-up', 'look-down', 'look-center');
        pupil.classList.add('look-center');
      });

      // 等待回到中心后开始转圈
      setTimeout(() => {
        pupils.forEach(pupil => {
          pupil.classList.remove('look-center');
          pupil.classList.add('thinking');
        });
      }, 300);

      // 10秒后自动停止
      thinkingTimeout = setTimeout(() => {
        stopThinking();
      }, 10000);
    }

    // 停止思考动画
    function stopThinking() {
      isThinking = false;
      if (thinkingTimeout) {
        clearTimeout(thinkingTimeout);
        thinkingTimeout = null;
      }
      
      pupils.forEach(pupil => {
        pupil.classList.remove('thinking');
        pupil.classList.add('look-center');
      });
    }

    // 移动眼睛位置
    function moveEyes(position) {
      eyes.forEach(eye => {
        // 移除所有位置类和3D朝向类（避免transform冲突）
        eye.classList.remove('position-up', 'position-down', 'position-left', 'position-right', 'position-center',
          'position-up-left', 'position-up-right', 'position-down-left', 'position-down-right',
          'face-normal', 'face-up', 'face-down', 'face-left', 'face-right');
        // 添加新位置类
        if (position !== 'center') {
          eye.classList.add(`position-${position}`);
        } else {
          eye.classList.add('position-center');
        }
      });
    }

    // 设置眼睛3D朝向
    function setFaceOrientation(orientation) {
      eyes.forEach(eye => {
        // 移除所有位置类和3D朝向类（避免transform冲突）
        eye.classList.remove('position-up', 'position-down', 'position-center',
          'position-up-left', 'position-up-right', 'position-down-left', 'position-down-right',
          'face-normal', 'face-up', 'face-down', 'face-left', 'face-right');
        // 添加新的3D朝向类
        if (orientation && orientation !== 'normal') {
          eye.classList.add(`face-${orientation}`);
        } else {
          eye.classList.add('face-normal');
        }
      });
    }

    // 设置嘴巴样式
    function setMouthStyle(style) {
      const mouth = document.querySelector('.mouth');
      if (!mouth) return;
      
      // 移除所有嘴巴样式类（包括说话动画）
      mouth.classList.remove('line', 'circle', 'arc-up', 'arc-down', 'rectangle', 'speaking');
      // 添加新的嘴巴样式类
      if (style) {
        mouth.classList.add(style);
      } else {
        mouth.classList.add('line'); // 默认横线
      }
    }

    // 控制说话状态
    let isSpeaking = false;
    let speakingInterval = null;

    function toggleSpeaking() {
      const mouth = document.querySelector('.mouth');
      if (!mouth) return;

      if (isSpeaking) {
        // 停止说话
        isSpeaking = false;
        if (speakingInterval) {
          clearInterval(speakingInterval);
          speakingInterval = null;
        }
        mouth.classList.remove('speaking');
        mouth.classList.add('line'); // 恢复默认横线
      } else {
        // 开始说话
        isSpeaking = true;
        mouth.classList.remove('line', 'circle', 'arc-up', 'arc-down', 'rectangle');
        mouth.classList.add('speaking');
      }
    }

    // 持续眨眼功能 - 不管什么情况下都要眨眼
    setInterval(() => {
      triggerBlink();
    }, 3000 + Math.random() * 2000); // 3-5秒随机眨眼

    // 情绪系统
    let currentEmotion = null;
    let emotionInterval = null;
    let randomActionInterval = null;

    // 可用的瞳孔动作（除了思考）
    const pupilActions = ['left', 'right', 'up', 'down', 'up-left', 'up-right', 'down-left', 'down-right', 'center'];
    
    // 可用的眼睛动作
    const eyeActions = ['up', 'down', 'left', 'right', 'up-left', 'up-right', 'down-left', 'down-right', 'center'];
    const eye3DActions = ['up', 'down', 'left', 'right', 'normal'];

    // 随机选择数组中的元素
    function randomChoice(array) {
      return array[Math.floor(Math.random() * array.length)];
    }

    // 随机选择瞳孔动作
    function randomPupilAction(exclude = []) {
      const available = pupilActions.filter(action => !exclude.includes(action));
      return available.length > 0 ? randomChoice(available) : 'center';
    }

    // 随机选择眼睛动作
    function randomEyeAction(exclude = [], use3D = false) {
      if (use3D) {
        const available = eye3DActions.filter(action => !exclude.includes(action));
        return available.length > 0 ? randomChoice(available) : 'normal';
      } else {
        const available = eyeActions.filter(action => !exclude.includes(action));
        return available.length > 0 ? randomChoice(available) : 'center';
      }
    }

    // 随机调整眼睛和瞳孔位置
    function randomAdjustEyesAndPupils(emotion) {
      if (!emotion) return;

      switch(emotion) {
        case 'normal':
          lookDirection(randomPupilAction(['thinking']));
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
        
        case 'happy':
          lookDirection(randomPupilAction(['thinking']));
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction(['down']));
          } else {
            setFaceOrientation(randomEyeAction(['down'], true));
          }
          break;
        
        case 'sad':
          lookDirection(randomPupilAction(['thinking', 'up']));
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction(['up']));
          } else {
            setFaceOrientation(randomEyeAction(['up'], true));
          }
          break;
        
        case 'thinking':
          triggerThinking();
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
        
        case 'cunning':
          triggerThinking();
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
        
        case 'speaking':
          if (!isSpeaking) {
            toggleSpeaking();
          }
          if (Math.random() > 0.5) {
            lookDirection(randomPupilAction());
          }
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
      }
    }

    // 设置情绪
    function setEmotion(emotion) {
      // 清除之前的情绪
      if (emotionInterval) {
        clearInterval(emotionInterval);
        emotionInterval = null;
      }
      if (randomActionInterval) {
        clearInterval(randomActionInterval);
        randomActionInterval = null;
      }
      if (isThinking) {
        stopThinking();
      }
      if (isSpeaking) {
        toggleSpeaking();
      }

      currentEmotion = emotion;

      // 清除所有状态
      eyes.forEach(eye => {
        eye.classList.remove('position-up', 'position-down', 'position-left', 'position-right', 'position-center',
          'position-up-left', 'position-up-right', 'position-down-left', 'position-down-right',
          'face-normal', 'face-up', 'face-down', 'face-left', 'face-right');
      });
      pupils.forEach(pupil => {
        pupil.classList.remove('look-left', 'look-right', 'look-up', 'look-down', 
          'look-up-left', 'look-up-right', 'look-down-left', 'look-down-right',
          'look-center', 'thinking', 'blinking');
      });

      const mouth = document.querySelector('.mouth');
      if (mouth) {
        mouth.classList.remove('line', 'circle', 'arc-up', 'arc-down', 'speaking');
      }

      switch(emotion) {
        case 'normal':
          setMouthStyle('line');
          lookDirection(randomPupilAction(['thinking']));
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
        
        case 'happy':
          setMouthStyle('arc-up');
          lookDirection(randomPupilAction(['thinking']));
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction(['down']));
          } else {
            setFaceOrientation(randomEyeAction(['down'], true));
          }
          break;
        
        case 'sad':
          setMouthStyle('arc-down');
          lookDirection(randomPupilAction(['thinking', 'up']));
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction(['up']));
          } else {
            setFaceOrientation(randomEyeAction(['up'], true));
          }
          break;
        
        case 'thinking':
          setMouthStyle('circle');
          triggerThinking();
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
        
        case 'cunning':
          setMouthStyle(Math.random() > 0.5 ? 'circle' : 'arc-up');
          triggerThinking();
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
        
        case 'speaking':
          if (!isSpeaking) {
            toggleSpeaking();
          }
          lookDirection(randomPupilAction());
          if (Math.random() > 0.5) {
            moveEyes(randomEyeAction());
          } else {
            setFaceOrientation(randomEyeAction([], true));
          }
          break;
      }

      // 设置随机动作调整（10秒以内）
      randomActionInterval = setInterval(() => {
        randomAdjustEyesAndPupils(emotion);
      }, 3000 + Math.random() * 7000); // 3-10秒随机
    }

    // 初始化：随机情绪
    const emotions = ['normal', 'happy', 'sad', 'thinking', 'cunning'];
    setEmotion(randomChoice(emotions));

    // ========== ASR 语音识别集成 ==========
    let asrManager = null;
    let asrInitialized = false;

    // 初始化 ASR（延迟加载，避免影响启动速度）
    async function initASR() {
      if (asrInitialized) return;
      
      try {
        // 动态导入 ASR 管理器
        const ASRManagerModule = await import('./asr-manager.js');
        asrManager = ASRManagerModule.default;

        // 设置识别结果回调
        asrManager.onResult((text) => {
          console.log('ASR 识别结果:', text);
          // 可以在这里处理识别结果，比如显示在界面上或触发某些动作
          // 例如：让机器人"说话"或做出反应
          if (text && text.trim()) {
            // 触发说话动画
            toggleSpeaking();
          }
        });

        // 设置句子完成回调
        asrManager.onSentenceComplete((text) => {
          console.log('句子完成:', text);
          // 可以在这里处理完整句子（但未调用 AI 的情况）
        });

        // 设置 AI 响应回调
        asrManager.onAIResponse(async (userInput, aiResponse) => {
          console.log('用户输入:', userInput);
          console.log('AI 回复:', aiResponse);
          // 可以在这里处理 AI 响应，比如显示回复或触发机器人动作
          // 例如：让机器人"说话"或做出反应
          if (aiResponse && aiResponse.trim()) {
            // 触发说话动画
            toggleSpeaking();
            
            // 文本转语音并播放
            try {
              const TTSManagerModule = await import('./tts-manager.js');
              const ttsManager = TTSManagerModule.default;
              
              // 初始化 TTS（如果还没初始化）
              if (!ttsManager.isConnected) {
                await ttsManager.init();
              }
              
              // 合成并播放语音
              await ttsManager.speak(aiResponse);
              console.log('TTS 播放完成');
            } catch (error) {
              console.error('TTS 播放失败:', error);
            }
          }
        });

        // 设置错误回调
        asrManager.onError((error) => {
          console.error('ASR 错误:', error);
        });

        // 优化：初始化时预先准备连接和权限
        await asrManager.init();

        asrInitialized = true;
        console.log('ASR 管理器初始化完成');
      } catch (error) {
        console.error('ASR 初始化失败:', error);
        console.warn('ASR 功能将不可用，请确保已安装模型文件');
      }
    }

    // 触摸/点击检测
    let touchEvents = ['mousedown', 'touchstart', 'click'];
    let lastTouchTime = 0;
    const TOUCH_DEBOUNCE = 100; // 防抖：100ms 内的多次触摸只算一次

    touchEvents.forEach(eventType => {
      document.addEventListener(eventType, (e) => {
        const now = Date.now();
        if (now - lastTouchTime < TOUCH_DEBOUNCE) {
          return; // 防抖
        }
        lastTouchTime = now;

        // 初始化 ASR（如果还没初始化）
        if (!asrInitialized) {
          initASR();
        }

        // 通知 ASR 管理器检测到触摸
        if (asrManager) {
          asrManager.touchDetected();
        }
      }, { passive: true });
    });

    // 鼠标移动也重置休眠定时器（更自然的交互）
    document.addEventListener('mousemove', () => {
      if (asrManager && asrManager.isActive) {
        asrManager.resetSleepTimer();
      }
    }, { passive: true });

    // 页面加载完成后延迟初始化 ASR 和 TTS（不阻塞页面加载）
    window.addEventListener('load', async () => {
      setTimeout(async () => {
        await initASR();
        
        // 初始化 TTS（延迟加载）
        try {
          const TTSManagerModule = await import('./tts-manager.js');
          const ttsManager = TTSManagerModule.default;
          await ttsManager.init();
          console.log('TTS 管理器初始化完成');
        } catch (error) {
          console.warn('TTS 初始化失败（将在使用时重试）:', error);
        }
      }, 2000); // 2秒后初始化，确保页面完全加载
    });
  </script>
</body>
</html>

